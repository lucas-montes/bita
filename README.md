# Bitacore Mini - Backtesting API

[memray](https://github.com/bloomberg/memray)
[pytest-benchmark](https://pytest-benchmark.readthedocs.io/en/latest/usage.html)

## Context
Platform for running backtests of indices using custom rules through APIs.
Running a backtest of an index can be summarized in the following steps:
1. Portfolio Creation: The user is able to select the securities that will be part of his portfolio in a way that
adapts as much as possible to his necessities, to cover most of the cases Bitacore offers a set of generic filters that
control how the securities are excluded or maintained on the portfolio during the history, the portfolio of the client
must be reviewed every certain time, for that reason we also offer a set of calendar rules to determine the dates for
reviewing the portfolio.
2. Weighting: The weighting is an operation at which Bitacore determines what percentage of the capital invested will
be assigned to every security on the portfolio, this can be visualized as a numeric value assigned to every security
but the sum of the weights of all the securities on a single date must be 100% during this test.
3. Index Calculation: An index can be understood as a numeric score to track the performance of a group of
securities (it's a time series). To keep the test tolerable in terms of time you will not need to implement this part.
Take into account that you'll be performing a backtest. This means that the weighting and filtering steps are applied
independently on every date generated by the calendar, resulting in one portfolio per date. (See the Expected Output
section for more details.)

All the data fields used in the test are stored in Parquet files in a kind of matrix format which can be summarized as
follows:
Index: Every element of the index is a date, and you can understand a row as the data for all the securities at the
close of the market on the date.
Columns: Every column represents a security, and all of them have a unique identifier (integers in string format).
Values: Every cell of the matrix represents the value for a security on a date. For example, if the matrix represents
the prices, every cell of the matrix would be the price of the security at the close of that day.
Each dataset has a unique identifier, the user will provide it as an input on the backtest endpoint. Refer to the Data

possible to select one weighting method per backtest:
1. Equal Weight:
Implementation: If there are n  securities, each receives a weight of 1/n .
2. Optimized Weight:


This generates random data for:
market_capitalization
prices
volume
adtv_3_month  (Average Daily Trading Volume over 3 months)
Each file contains dates as the index and securities as the columns.

## Notes
1. Using the pyarrow backend can drive some perf improvements
2. Reading the files with pyarrow instead of pandas can allow to do some predicate pushdown
3. Memray or pytest-benchmark could be used in tests to have better restrictions memory and performance wise
4. Use locust to measure the performance of the overall app

## Getting Started

### Installation

#### Using Python

1. Clone the repository:
   ```bash
   git clone https://github.com/lucas-montes/bita.git
   cd bita
   ```

2. Install dependencies:
  If you don't use nix and direnv you may want to create a virtualenv before installing
   ```bash
   pip install -r requirements.txt
   ```

3. Generate test data:
   ```bash
   python generate_data.py --path ./data --num_securities 1000
   ```

4. Run the server:
   ```bash
   fastapi dev bita
   ```

#### Using Docker

Build and run with Docker:
```bash
docker compose up --build
```

### API Usage
You can find the docs at:
```
localhost:8000/docs
```

### Running Tests

You can either use
```bash
PYTHONPATH=$(pwd) pytest
```

Or install the app an run
```bash
pytest
```
